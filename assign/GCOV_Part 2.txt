
What is code coverage?
Code coverage is a measure used in software testing. It describes the degree to which the source code of a program has been tested. It is a form of testing that inspects the code directly and is therefore a form of white box testing. 
Basic coverage criteria
There are a number of coverage criteria, the main ones being:
	Function coverage - Has each function in the program been called?
	Statement coverage - Has each node in the program been executed?
	Decision coverage (not the same as branch coverage.) - Has every edge in the program been executed? For instance, have the requirements of each branch of each control structure (such as in If and CASE statement been met as well as not met?
	Condition coverage (or predicate coverage) - Has each Boolean sub-expression evaluated both to true and false? This does not necessarily imply decision coverage.
	Condition/decision coverage - Both decision and condition coverage should be satisfied.

Tool for code coverage:
Gcov   is a tool   used for code coverage analysis. It is used   with GCC to analyze programs and it helps to create more efficient, faster running code and to discover untested parts of a program. 
Some basic performance statistics, such as below can be found out using Gcov

o	How often each line of code executes?

o	What lines of code are actually executed ?

o	Which   lines of   code can  be executed but not executed?

Consider the following  code  
Now type the following commands to use gcov, which clarify the above three questions. 
	After saving the c source code write the following command sequentially.
1.	gcc –ftest-coverage  -fprofile-arcs <filename>
2.	 it creates the <filename.gcno > file, using the ls command the created  .gcno file can seen. GCNO file is a Gcov Metadata File. Gcov is a test coverage program. Use it in concert with GCC to analyze your programs to help create more efficient, faster running code and to discover untested parts of your program.
3.	Now run the executable using  ./a.out  command, and enter the inputs. After that  it will create the <filename.gcda> file . Using the ls command the created  .gcda file can be seen. The data in the .gcda files is saved immediately before the program exits.  For each source file compiled with -fprofile-arcs, the profiling code first attempts to read in an existing .gcda file; if the file doesn't match the executable (differing number of basic block counts)  it will ignore the contents of the file. It then adds in the new execution counts and finally writes the data to the file.

4.	Now type gcov  <filename>  . It will  create the .gcov file, which provide the information about the code coverage(given in %).

 

5.	To see the details of the code execution ,that which lines are executed and which are not executed , use the following command vi  <filename.c.gcov>

 


 


 

 

In the above picture we can see some important statistics, 
(- )    Defines that these lines are not executable lines. 
Eg (line number 0,1,2,3,9,11,12,13,17,20)
(#)   Defines these lines are executable lines but not executed yet.
	Eg (line number 14,15,16)
(number)  Defines how many times that particular   lines has been executed.
	Eg (line number 4,5,6,7,8,10,18,19) are executed ones.

The code coverage for the above source code is not 100%  (72.73%) because in this code line number 14, 15, 16 contains else block , which is not reached for this particular use input .The if condition is true in this  case. 
To get 100% code coverage we need to enter such inputs so that the  if condition become false, so that else block  is executed.
The execution counts are cumulative. If the example program were executed again without removing the .gcda file, the count for the number of times each line in the source was executed would be added to the results of the previous run(s). but if we compile the source code again then the previous .gcno file will be replaced and a new .gcda file will be created. So it is better not to compile the code again to get 100% code coverage.

The below input shows that : 
 

 

In the above picture the number (2) in front of line number 4, 5,6, 7, 8, 18,19 shows that these lines  are executed twice.

GCOV Example for Multiple Files
The below source code is the example how gcov used for multi file programs.
In this source code we are doing addition of two numbers and calculating the factorial of a number, depending on the user choice appropriate function will be called( If user input 1 the sum will be calculated, and if 2 is given then it will calculate the factorial and if anything else is given then it will show some message and program will be terminated) .
The source code for main function (File : test1.c ) and the other function definition (File:test2.c ) is given below:
 

The main function calls appropriate function depending on the user input.(File:Test1.c)
 
The above fig shows code for file:Test2.c
 
The above fig shows, compiling, executing and running gcov.
First time the user input 1, and for that sum function is called, and the below picture shows which lines are executed and which are not.
 
The above fig show the coverage results of the main function (in file test1.c)
In the fig below, The statement above line number 3   “function facto called 0 returned 0% blocks executed 0%” means that the facto function is not called during this execution.
The statement above line number 15 “function sum called 1 returned 100% blocks executed 100%” means that the sum function is called one time during this execution and all the statements   are executed.
 
Next time the user inputs 2, and for that facto function is called.
 


 
The above picture shows which lines are executed and which are not executed in the file test1.c.

 

In the fig above, the statement above line number 3   “function facto called 5 returned 100% blocks executed 100%” means that the facto function is   called 5 times recursively during this execution and all the statements are executed.
The statement above line number 15 “function sum called 1 returned 100% blocks executed 100%” means that the sum function is called one time during this execution and all the statements are executed. As we have not compiled the source code again, the previous data stored in the .gcda file remains unchanged, and for that, though the sum function is not executed this time it, is showing 100% execution.
Next time the user inputs 3, and for that default case is executed, and the below picture shows which lines are executed and which are not executed.
 


 

 

