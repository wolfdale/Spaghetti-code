/*************************************************************************************************
					HEADER
**************************************************************************************************/


#include "header.h"

/**************************************************************************
Function NAme: print_list
Description: print each element in list (used as iterator)
@argument : gpointer value , gpointer userdata
return type: it return void
**************************************************************************/ 
void print_list(gpointer value, gpointer userdata)
{
 	printf(" %s ",(char*)value);	
 	free(value);	
}

/**************************************************************************
Function NAme: print
Description: it print all the information related to file
@argument : gpointer value , gpointer userdata
return type: it return void
**************************************************************************/ 
void print(gpointer value, gpointer userdata)
{ 
  	g_slist_foreach((GSList*)value, (GFunc)print_list, NULL);
 	printf("\n");	 
	g_slist_free((GSList*)value);
}



/**************************************************************************
Function NAme: get_file_info
Description: gets all the file information and saves in a GSList
@argument : char pointer to absolute path of directory
return type: it return void
**************************************************************************/ 

void get_file_info(char *abs_path)
{
	GSList *detail_list  = NULL;
	GSList *file_list = NULL;
	struct stat    filestat;
	stat(abs_path, &filestat); 			//Initialize Stat Buffer
	struct passwd *pw = NULL;				//obtaining owner name
 	char *permission = (char*) malloc(11*sizeof(char));
 	char *user_temp = NULL;	 			//user id
 	char *link_temp = NULL;	 			//number of links
 	char *size_temp = NULL;	 			//filesize
  	char *mod_time = NULL;				//modification time
 	char *temp_mod_time = NULL;			//Modification time

 	link_temp = (char*)malloc(8*sizeof(char));
 	size_temp = (char*)malloc(8*sizeof(char));

 	memset(link_temp,0,8);
 	memset(size_temp,0,8);

 	/*setting file permissions*/
 	permission[0] = (S_ISDIR(filestat.st_mode)) ? 'd' : '-';
 	permission[1] =  (filestat.st_mode & S_IRUSR) ? 'r' : '-';
 	permission[2] =  (filestat.st_mode & S_IWUSR) ? 'w' : '-';
	permission[3] =  (filestat.st_mode & S_IXUSR) ? 'x' : '-';
 	permission[4] =  (filestat.st_mode & S_IRGRP) ? 'r' : '-';
 	permission[5] =  (filestat.st_mode & S_IWGRP) ? 'w' : '-';
 	permission[6] =  (filestat.st_mode & S_IXGRP) ? 'x' : '-';
 	permission[7] =  (filestat.st_mode & S_IROTH) ? 'r' : '-';
 	permission[8] =  (filestat.st_mode & S_IWOTH) ? 'w' : '-';
 	permission[9] =  (filestat.st_mode & S_IXOTH) ? 'x' : '-';
 	permission[10] = '\0';

 	/*For file owner information*/
 	if(NULL != (pw = getpwuid(filestat.st_uid)))
 	{
  		user_temp = (char*)malloc(sizeof(char) * (strlen(pw->pw_name)+1));
  		strcpy(user_temp , pw->pw_name);
 	}
 	else
 	{
  		user_temp = (char*)malloc(sizeof(char) * 8);
  		strcpy(user_temp ,"       ");
 	}
 	sprintf(link_temp, "%zd", filestat.st_nlink);
 	sprintf(size_temp, "%zd", filestat.st_size);

 	/*setting modification time*/
 	temp_mod_time = ctime(&(filestat.st_mtime));
 	mod_time = (char*)malloc(sizeof(char)*strlen(temp_mod_time)+1);
 	strcpy(mod_time,temp_mod_time);
 	mod_time[strlen(mod_time)-1] = '\0';	// To remove '\n' at the end of time
	

 	detail_list = g_slist_append(detail_list, permission);
 	detail_list = g_slist_append(detail_list, link_temp);
 	detail_list = g_slist_append(detail_list, user_temp);
 	detail_list = g_slist_append(detail_list, size_temp);
 	detail_list = g_slist_append(detail_list, mod_time);

	file_list = g_slist_append(file_list,detail_list);
	g_slist_foreach(file_list, print, NULL);
	g_slist_free(file_list);

}



/**************************************************************************
Function NAme: list_dir (list directory)
Description: it list all the files/directory within the directory
@argument : character pointer to name of directory as  argument
return type: it return void
**************************************************************************/ 
void list_dir (char * dir_name)
{
    	DIR * d;
	char abs_path[100];

    /* Open the directory specified by "dir_name". */

    d = opendir (dir_name);

    /* Check it was opened. */
    if (! d) {
        fprintf (stderr, "Cannot open directory '%s': %s\n",
                 dir_name, strerror (errno));
        exit (EXIT_FAILURE);
    }
    while (1) {
        struct dirent * entry;
        const char * d_name;

        /* "Readdir" gets subsequent entries from "d". */
        entry = readdir (d);
        if (! entry) {
            /* There are no more entries in this directory, so break
               out of the while loop. */
            break;
        }
        d_name = entry->d_name;
        /* Print the name of the file and directory. */
	//printf ("%s/%s\n", dir_name, d_name);


	/* If you don't want to print the directories, use the
	   following line: */

        if (! (entry->d_type & DT_DIR)) {
	    printf ("%s/%s", dir_name, d_name);
		strcpy(abs_path , dir_name);
		strcat(abs_path, "/");
		strcat(abs_path,d_name);
		get_file_info(abs_path);
		printf("\n");
	}


	



        if (entry->d_type & DT_DIR) {

            /* Check that the directory is not "d" or d's parent. */
            
            if (strcmp (d_name, "..") != 0 &&
                strcmp (d_name, ".") != 0) {
                int path_length;
                char path[PATH_MAX];
 
                path_length = snprintf (path, PATH_MAX,
                                        "%s/%s", dir_name, d_name);
                //printf ("%s\n", path);
                if (path_length >= PATH_MAX) {
                    fprintf (stderr, "Path length has got too long.\n");
                    exit (EXIT_FAILURE);
                }
                /* Recursively call "list_dir" with the new path. */
                list_dir (path);
            }
	}
    }
    /* After going through all the entries, close the directory. */
    if (closedir (d)) {
        fprintf (stderr, "Could not close '%s': %s\n",
                 dir_name, strerror (errno));
        exit (EXIT_FAILURE);
    }
}
