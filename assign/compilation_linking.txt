Programming Tools - Compilation and linking hands-on reference

Typographical conventions

We use the following conventions in this guide:

gcc       		The name of a specific command or file
filename	             You should replace file with a specific name
WARNING		Output that you see on the screen

Getting started with gcc 

1.	Log into the Linux server using your respective ids

2.	Copy the C source file as directed by the facilitator. Compile the file with the following command:

gcc sourcefilename.c

Where sourcefilename.c is the name of the C source code

3.	Observe the executable formed is called a.out. Execute the file using the command:

./a.out

(Here ./ implies that the path of a.out is the current directory)

4.	Once again compile the source code with the following command:

gcc –o outputfilename sourcefilename.c

Where outputfilename is the name of the executable file. After this command gets executed successfully, the name of the executable is not a.out but whatever is given as outputfilename 

Execute the output file using the command:
./outputfilename

Object files

5.	Once again compile the source code with the following command:

gcc –c sourcefilename.c

Observe using ls that an object file called sourcefilename.o is created in the directory

What is the difference between an executable and an object file? 

Now, create the executable from the object file using the following command:

gcc sourcefilename.o

Preprocessor directives

6.	GROUP ACTIVITY: Copy all the programs as directed by the facilitator. (Programs: prepr1.c, prepr2.c, prepr3.c, prepr4.c, prepr5.c, prepr6.c, prepr7.c) Each group will go through one program and find out what should be the result of these programs after preprocessing. Note that you only have to concentrate till the preprocessed stage.

After thinking the answers, preprocess your program with the following command:

gcc –E sourcefilename.c

7.	Each group presents their findings to the class and then the rest of the groups will also preprocess the source file of the group, which is presenting.

Additional gcc switches

8.	Copy the program program_warn.c as directed by the facilitator. Compile the program using gcc without any switch. Observe the result of compilation

9.	Now, compile the program with the –Wall switch. Observe the warnings that are now given by the compiler.

10.	Now, compile the program with the –ansi switch. Observe the warnings that are now given by the compiler.


Compiler’s output

11.	Copy the program program.c as directed by the facilitator. Compile the programs using gcc with the -S option such that only compilation takes place and assembling does not take place. Do this exercise on a solaris sparc server

Observe that variables are represented as addresses and not as names in the resulting low-level code

Linking

12.	Write a program linking1.c, which has main function. Inside main there should be a call to another function which is defined in another file linking2.c

13.	Compile the file linking1.c using the following command:
gcc –c –Wall linking1.c

Observe the warnings received

Again compile the file linking1.c using the following command:
gcc –Wall linking1.c

Observe the errors received

14.	Now create a header file prototype.h, which contains the prototype of the function defined in linking2.c. Include this file in linking1.c using the following statement:

#include <prototype.h>

and again compile linking1.c using the following command:

gcc –I. –c –Wall linking1.c

The –I switch tells gcc where the included header files have to be searched. Thus –I. implies that the current directory needs to be searched by gcc

Compare the result with the earlier compilation using the same command

15.	Similar effect can be achieved by including the file prototype.h using the following 
command

#include “prototype.h”

and then compiling using the following command
gcc –c –Wall linking1.c

If the included file name is given in double quotes, searching for the file typically starts where the source program was found. If it is not found there, then searching follows the paths given by the –I flag and implementation defined paths.

If the included file name is given in <>, searching follows the paths given by the –I flag and implementation defined paths.

16.	Now after all the compilation warnings have been removed, link the 2 files together:

gcc –c –Wall linking1.c
gcc –c –Wall linking2.c
gcc linking1.o linking2.o

17.	Do not include the header file prototype.h containing the prototype of the function in the file linking1.c.
Instead of that include the file linking2.c in the file linking1.c using the following statement:
#include “linking2.c”

Now repeat the following three commands:

gcc –c –Wall linking1.c
gcc –c –Wall linking2.c
gcc linking1.o linking2.o

Observe the error received.

Thus we see that the inclusion of a C source file in another C source file is NOT a correct way of writing programs. Imagine a scenario where there are 100 source files each having function calls to functions defined in other files. It would be a chaos trying to include files in each other, with no guarantee that the files would compile successfully

Is it right to include C function definitions instead of their prototypes in a header file?
•	From the above explanation, it follows that header files should only contain declarations (prototypes) of functions and not their definitions

Is it right to include C global variable definitions in a header file?
•	If a global variable is defined in a header file, and that header file is included in multiple source files linked together, then it would give an error of multiple definitions for a single variable. Thus global variables should be defined in a C source file, while its extern declaration may be included in a header file. This header file may then be included in all the other source files accessing that global variable

18.	Do not include the file linking2.c in linking1.c. Instead of that include the file prototype.h and proceed as mentioned in the points 15 and 16.

19.	A shell script is a collection of commands that can be executed on the shell. Create a script doCompilation, which should contain the commands to compile both the C source files separately and then link them together as mentioned in point 16.

Execute the script with the following command:

sh doCompilation


Make

20.	See the commands in the script doCompilation and use them to write a makefile. Execute the makefile with the following command

make –f makefilename

Remember that if the name of the makefile is makefile itself then the following command is sufficient to execute the makefile

make

21.	Augment the makefile to include a rule called clean to remove the given executable and object files. Execute the makefile using the following command:

make –f makefilename clean

22.	Change only one source file and observe that on running the make command, only that file is recompiled and linked with the existing .o files of the other unchanged files.

23.	Augment the makefile for adding a macro CC for the compiler name gcc

24.	Suppose there is a change in the file prototype.h. Should linking1.c be compiled again?  If your answer is yes, then after making any change in the file prototype.h (Just add a comment), see if the file linking1.c compiled again when you execute the makefile.

If not, then review and modify your makefile to include this dependency of linking1.c on prototype.h.

25.	Copy the file called quiz_makefile as directed by the facilitator and answer the following questions:

a.	Where should the value of ESL_DEV_DIR be set?
b.	What is the significance of the INCLUDE macro?
c.	What is the significance of the SRCDIR macro?
d.	What is the significance of the OBJDIR macro?
e.	What is the significance of the SRCFILES macro?
f.	What is the significance of the OBJFILES macro?
g.	Discuss the targets, dependencies and commands in this makefile.

Libraries
26.	Create a file main.c which contains the main function. The main function contains calls to two functions defined in linking1.c and linking2.c respectively. The file prototype.h should contain the prototypes of both the functions and should be included in the file main.c

27.	Create a makefile for creating an archive (library) using the ar command. The library will be a collection of linking1.o and linking2.o and the final executable should be created using the library and main.o. Also keep the clean target in the makefile for removing all object files, executables and libraries

28.	Execute the executable created above.

29.	Create a makefile for creating a shared library using the gcc command. The library will be a collection of linking1.o and linking2.o and the final executable should be created using the library and main.o. Also keep the clean target in the makefile for removing all object files, executables and libraries

30.	Execute the executable created above. Before running the executable, set the environment variable LD_LIBRARY_PATH to the path where the shared library is stored. E.g. if the shared library is saved in the current directory, execute the following command:

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
